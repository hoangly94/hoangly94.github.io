import{getErrorMessage,logMessage}from"./helpers";export class DataPulseProvider{constructor(e,s){this._subscribers={},this._requestsPending=0,this._historyProvider=e,setInterval(this._updateData.bind(this),s)}subscribeBars(e,s,r,t){this._subscribers.hasOwnProperty(t)?logMessage(`DataPulseProvider: already has subscriber with id=${t}`):(this._subscribers[t]={lastBarTime:null,listener:r,resolution:s,symbolInfo:e},logMessage(`DataPulseProvider: subscribed for #${t} - {${e.name}, ${s}}`))}unsubscribeBars(e){delete this._subscribers[e],logMessage(`DataPulseProvider: unsubscribed for #${e}`)}_updateData(){if(!(this._requestsPending>0)){this._requestsPending=0;for(const e in this._subscribers)this._requestsPending+=1,this._updateDataForSubscriber(e).then((()=>{this._requestsPending-=1,logMessage(`DataPulseProvider: data for #${e} updated successfully, pending=${this._requestsPending}`)})).catch((s=>{this._requestsPending-=1,logMessage(`DataPulseProvider: data for #${e} updated with error=${getErrorMessage(s)}, pending=${this._requestsPending}`)}))}}_updateDataForSubscriber(e){const s=this._subscribers[e],r=parseInt((Date.now()/1e3).toString()),t=r-periodLengthSeconds(s.resolution,10);return this._historyProvider.getBars(s.symbolInfo,s.resolution,{from:t,to:r,countBack:2,firstDataRequest:!1}).then((s=>{this._onSubscriberDataReceived(e,s)}))}_onSubscriberDataReceived(e,s){if(!this._subscribers.hasOwnProperty(e))return void logMessage(`DataPulseProvider: Data comes for already unsubscribed subscription #${e}`);const r=s.bars;if(0===r.length)return;const t=r[r.length-1],i=this._subscribers[e];if(null!==i.lastBarTime&&t.time<i.lastBarTime)return;if(null!==i.lastBarTime&&t.time>i.lastBarTime){if(r.length<2)throw new Error("Not enough bars in history for proper pulse update. Need at least 2.");const e=r[r.length-2];i.listener(e)}i.lastBarTime=t.time,i.listener(t)}}function periodLengthSeconds(e,s){let r=0;return r="D"===e||"1D"===e?s:"M"===e||"1M"===e?31*s:"W"===e||"1W"===e?7*s:s*parseInt(e)/1440,24*r*60*60}